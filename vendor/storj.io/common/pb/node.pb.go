// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: node.proto

package pb

import (
	time "time"

	proto "github.com/gogo/protobuf/proto"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NodeType is an enum of possible node types.
type NodeType int32 // Deprecated: Do not use.
const (
	NodeType_INVALID NodeType = 0
	NodeType_STORAGE NodeType = 2
)

var NodeType_name = map[int32]string{
	0: "INVALID",
	2: "STORAGE",
}

var NodeType_value = map[string]int32{
	"INVALID": 0,
	"STORAGE": 2,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}

// NodeTransport is an enum of possible transports for the overlay network.
type NodeTransport int32

const (
	NodeTransport_TCP_TLS_RPC   NodeTransport = 0
	NodeTransport_QUIC_RPC      NodeTransport = 1
	NodeTransport_TCP_NOISE_RPC NodeTransport = 2
)

var NodeTransport_name = map[int32]string{
	0: "TCP_TLS_RPC",
	1: "QUIC_RPC",
	2: "TCP_NOISE_RPC",
}

var NodeTransport_value = map[string]int32{
	"TCP_TLS_RPC":   0,
	"QUIC_RPC":      1,
	"TCP_NOISE_RPC": 2,
}

func (x NodeTransport) String() string {
	return proto.EnumName(NodeTransport_name, int32(x))
}

type NodeAddress_Feature int32

const (
	NodeAddress_NO_FEATURES NodeAddress_Feature = 0
	// these must all be powers of two, since they are bitwise ORed into
	// the features field.
	NodeAddress_TCP_FASTOPEN_ENABLED NodeAddress_Feature = 1
)

var NodeAddress_Feature_name = map[int32]string{
	0: "NO_FEATURES",
	1: "TCP_FASTOPEN_ENABLED",
}

var NodeAddress_Feature_value = map[string]int32{
	"NO_FEATURES":          0,
	"TCP_FASTOPEN_ENABLED": 1,
}

func (x NodeAddress_Feature) String() string {
	return proto.EnumName(NodeAddress_Feature_name, int32(x))
}

// Node represents a serialized NodeURL. A NodeURL should be able to be
// converted to a pb.Node and vice versa.
type Node struct {
	Id                   NodeID       `protobuf:"bytes,1,opt,name=id,proto3,customtype=NodeID" json:"id"`
	Address              *NodeAddress `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}

func (m *Node) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Node.Unmarshal(m, b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Node.Marshal(b, m, deterministic)
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return xxx_messageInfo_Node.Size(m)
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetAddress() *NodeAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

// NodeAddress contains the information needed to communicate with a node on
// the network.
type NodeAddress struct {
	Address   string     `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	NoiseInfo *NoiseInfo `protobuf:"bytes,3,opt,name=noise_info,json=noiseInfo,proto3" json:"noise_info,omitempty"`
	// the number of concurrent identical messages this node knows how to
	// debounce. restricted to a specific protocol (e.g. just TLS or just Noise).
	DebounceLimit        int32    `protobuf:"varint,4,opt,name=debounce_limit,json=debounceLimit,proto3" json:"debounce_limit,omitempty"`
	Features             uint64   `protobuf:"varint,5,opt,name=features,proto3" json:"features,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeAddress) Reset()         { *m = NodeAddress{} }
func (m *NodeAddress) String() string { return proto.CompactTextString(m) }
func (*NodeAddress) ProtoMessage()    {}

func (m *NodeAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeAddress.Unmarshal(m, b)
}
func (m *NodeAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeAddress.Marshal(b, m, deterministic)
}
func (m *NodeAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAddress.Merge(m, src)
}
func (m *NodeAddress) XXX_Size() int {
	return xxx_messageInfo_NodeAddress.Size(m)
}
func (m *NodeAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAddress.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAddress proto.InternalMessageInfo

func (m *NodeAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NodeAddress) GetNoiseInfo() *NoiseInfo {
	if m != nil {
		return m.NoiseInfo
	}
	return nil
}

func (m *NodeAddress) GetDebounceLimit() int32 {
	if m != nil {
		return m.DebounceLimit
	}
	return 0
}

func (m *NodeAddress) GetFeatures() uint64 {
	if m != nil {
		return m.Features
	}
	return 0
}

// NodeOperator contains info about the storage node operator.
type NodeOperator struct {
	Email                string   `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Wallet               string   `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	WalletFeatures       []string `protobuf:"bytes,3,rep,name=wallet_features,json=walletFeatures,proto3" json:"wallet_features,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeOperator) Reset()         { *m = NodeOperator{} }
func (m *NodeOperator) String() string { return proto.CompactTextString(m) }
func (*NodeOperator) ProtoMessage()    {}

func (m *NodeOperator) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeOperator.Unmarshal(m, b)
}
func (m *NodeOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeOperator.Marshal(b, m, deterministic)
}
func (m *NodeOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeOperator.Merge(m, src)
}
func (m *NodeOperator) XXX_Size() int {
	return xxx_messageInfo_NodeOperator.Size(m)
}
func (m *NodeOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeOperator.DiscardUnknown(m)
}

var xxx_messageInfo_NodeOperator proto.InternalMessageInfo

func (m *NodeOperator) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *NodeOperator) GetWallet() string {
	if m != nil {
		return m.Wallet
	}
	return ""
}

func (m *NodeOperator) GetWalletFeatures() []string {
	if m != nil {
		return m.WalletFeatures
	}
	return nil
}

// NodeCapacity contains all relevant data about a nodes ability to store data.
type NodeCapacity struct {
	FreeBandwidth        int64    `protobuf:"varint,1,opt,name=free_bandwidth,json=freeBandwidth,proto3" json:"free_bandwidth,omitempty"` // Deprecated: Do not use.
	FreeDisk             int64    `protobuf:"varint,2,opt,name=free_disk,json=freeDisk,proto3" json:"free_disk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeCapacity) Reset()         { *m = NodeCapacity{} }
func (m *NodeCapacity) String() string { return proto.CompactTextString(m) }
func (*NodeCapacity) ProtoMessage()    {}

func (m *NodeCapacity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeCapacity.Unmarshal(m, b)
}
func (m *NodeCapacity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeCapacity.Marshal(b, m, deterministic)
}
func (m *NodeCapacity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCapacity.Merge(m, src)
}
func (m *NodeCapacity) XXX_Size() int {
	return xxx_messageInfo_NodeCapacity.Size(m)
}
func (m *NodeCapacity) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCapacity.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCapacity proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *NodeCapacity) GetFreeBandwidth() int64 {
	if m != nil {
		return m.FreeBandwidth
	}
	return 0
}

func (m *NodeCapacity) GetFreeDisk() int64 {
	if m != nil {
		return m.FreeDisk
	}
	return 0
}

// Deprecated: use NodeOperator instead.
type NodeMetadata struct {
	Email                string   `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Wallet               string   `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeMetadata) Reset()         { *m = NodeMetadata{} }
func (m *NodeMetadata) String() string { return proto.CompactTextString(m) }
func (*NodeMetadata) ProtoMessage()    {}

func (m *NodeMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeMetadata.Unmarshal(m, b)
}
func (m *NodeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeMetadata.Marshal(b, m, deterministic)
}
func (m *NodeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeMetadata.Merge(m, src)
}
func (m *NodeMetadata) XXX_Size() int {
	return xxx_messageInfo_NodeMetadata.Size(m)
}
func (m *NodeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_NodeMetadata proto.InternalMessageInfo

func (m *NodeMetadata) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *NodeMetadata) GetWallet() string {
	if m != nil {
		return m.Wallet
	}
	return ""
}

// Deprecated: use NodeCapacity instead.
type NodeRestrictions struct {
	FreeBandwidth        int64    `protobuf:"varint,1,opt,name=free_bandwidth,json=freeBandwidth,proto3" json:"free_bandwidth,omitempty"`
	FreeDisk             int64    `protobuf:"varint,2,opt,name=free_disk,json=freeDisk,proto3" json:"free_disk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeRestrictions) Reset()         { *m = NodeRestrictions{} }
func (m *NodeRestrictions) String() string { return proto.CompactTextString(m) }
func (*NodeRestrictions) ProtoMessage()    {}

func (m *NodeRestrictions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeRestrictions.Unmarshal(m, b)
}
func (m *NodeRestrictions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeRestrictions.Marshal(b, m, deterministic)
}
func (m *NodeRestrictions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRestrictions.Merge(m, src)
}
func (m *NodeRestrictions) XXX_Size() int {
	return xxx_messageInfo_NodeRestrictions.Size(m)
}
func (m *NodeRestrictions) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRestrictions.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRestrictions proto.InternalMessageInfo

func (m *NodeRestrictions) GetFreeBandwidth() int64 {
	if m != nil {
		return m.FreeBandwidth
	}
	return 0
}

func (m *NodeRestrictions) GetFreeDisk() int64 {
	if m != nil {
		return m.FreeDisk
	}
	return 0
}

// NodeVersion contains version information about a node.
type NodeVersion struct {
	Version              string    `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	CommitHash           string    `protobuf:"bytes,2,opt,name=commit_hash,json=commitHash,proto3" json:"commit_hash,omitempty"`
	Timestamp            time.Time `protobuf:"bytes,3,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Release              bool      `protobuf:"varint,4,opt,name=release,proto3" json:"release,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NodeVersion) Reset()         { *m = NodeVersion{} }
func (m *NodeVersion) String() string { return proto.CompactTextString(m) }
func (*NodeVersion) ProtoMessage()    {}

func (m *NodeVersion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeVersion.Unmarshal(m, b)
}
func (m *NodeVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeVersion.Marshal(b, m, deterministic)
}
func (m *NodeVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeVersion.Merge(m, src)
}
func (m *NodeVersion) XXX_Size() int {
	return xxx_messageInfo_NodeVersion.Size(m)
}
func (m *NodeVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeVersion.DiscardUnknown(m)
}

var xxx_messageInfo_NodeVersion proto.InternalMessageInfo

func (m *NodeVersion) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *NodeVersion) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *NodeVersion) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *NodeVersion) GetRelease() bool {
	if m != nil {
		return m.Release
	}
	return false
}
