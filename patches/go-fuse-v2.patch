--- vendor/github.com/hanwen/go-fuse/v2/fs/bridge.go.orig	2025-11-24 10:40:02
+++ vendor/github.com/hanwen/go-fuse/v2/fs/bridge.go	2025-11-24 10:56:20
@@ -346,9 +346,16 @@
 func (b *rawBridge) inode(id uint64, fh uint64) (*Inode, *fileEntry) {
 	b.mu.Lock()
 	defer b.mu.Unlock()
-	n, f := b.kernelNodeIds[id], b.files[fh]
+	n := b.kernelNodeIds[id]
 	if n == nil {
 		log.Panicf("unknown node %d", id)
+	}
+
+	// Bounds check to prevent panic from corrupted file handle values
+	// This can happen in concurrent multi-mount scenarios
+	var f *fileEntry
+	if fh > 0 && fh < uint64(len(b.files)) {
+		f = b.files[fh]
 	}
 	return n, f
 }
@@ -545,17 +552,25 @@
 
 func (b *rawBridge) GetAttr(cancel <-chan struct{}, input *fuse.GetAttrIn, out *fuse.AttrOut) fuse.Status {
 	n, fEntry := b.inode(input.NodeId, input.Fh())
-	f := fEntry.file
+	var f FileHandle
+	if fEntry != nil {
+		f = fEntry.file
+	}
 	if f == nil {
 		// The linux kernel doesnt pass along the file
 		// descriptor, so we have to fake it here.
 		// See https://github.com/libfuse/libfuse/issues/62
 		b.mu.Lock()
 		for _, fh := range n.openFiles {
-			f = b.files[fh].file
-			b.files[fh].wg.Add(1)
-			defer b.files[fh].wg.Done()
-			break
+			// Bounds check to prevent panic from corrupted openFiles entries
+			// This can happen in concurrent multi-mount scenarios where
+			// n.openFiles contains stale/invalid file handle values
+			if fh < uint32(len(b.files)) && b.files[fh] != nil {
+				f = b.files[fh].file
+				b.files[fh].wg.Add(1)
+				defer b.files[fh].wg.Done()
+				break
+			}
 		}
 		b.mu.Unlock()
 	}
@@ -592,7 +607,10 @@
 	fh, _ := in.GetFh()
 
 	n, fEntry := b.inode(in.NodeId, fh)
-	f := fEntry.file
+	var f FileHandle
+	if fEntry != nil {
+		f = fEntry.file
+	}
 
 	var errno = syscall.ENOTSUP
 	if fops, ok := n.ops.(NodeSetattrer); ok {
@@ -852,11 +870,15 @@
 	n, f := b.inode(input.NodeId, input.Fh)
 
 	ctx := &fuse.Context{Caller: input.Caller, Cancel: cancel}
+	var fh FileHandle
+	if f != nil {
+		fh = f.file
+	}
 	if fops, ok := n.ops.(NodeReader); ok {
-		res, errno := fops.Read(ctx, f.file, buf, int64(input.Offset))
+		res, errno := fops.Read(ctx, fh, buf, int64(input.Offset))
 		return res, errnoToStatus(errno)
 	}
-	if fr, ok := f.file.(FileReader); ok {
+	if fr, ok := fh.(FileReader); ok {
 		res, errno := fr.Read(ctx, buf, int64(input.Offset))
 		return res, errnoToStatus(errno)
 	}
@@ -868,10 +890,14 @@
 	n, f := b.inode(input.NodeId, input.Fh)
 
 	ctx := &fuse.Context{Caller: input.Caller, Cancel: cancel}
+	var fh FileHandle
+	if f != nil {
+		fh = f.file
+	}
 	if lops, ok := n.ops.(NodeGetlker); ok {
-		return errnoToStatus(lops.Getlk(ctx, f.file, input.Owner, &input.Lk, input.LkFlags, &out.Lk))
+		return errnoToStatus(lops.Getlk(ctx, fh, input.Owner, &input.Lk, input.LkFlags, &out.Lk))
 	}
-	if gl, ok := f.file.(FileGetlker); ok {
+	if gl, ok := fh.(FileGetlker); ok {
 		return errnoToStatus(gl.Getlk(ctx, input.Owner, &input.Lk, input.LkFlags, &out.Lk))
 	}
 	return fuse.ENOTSUP
@@ -880,10 +906,14 @@
 func (b *rawBridge) SetLk(cancel <-chan struct{}, input *fuse.LkIn) fuse.Status {
 	n, f := b.inode(input.NodeId, input.Fh)
 	ctx := &fuse.Context{Caller: input.Caller, Cancel: cancel}
+	var fh FileHandle
+	if f != nil {
+		fh = f.file
+	}
 	if lops, ok := n.ops.(NodeSetlker); ok {
-		return errnoToStatus(lops.Setlk(ctx, f.file, input.Owner, &input.Lk, input.LkFlags))
+		return errnoToStatus(lops.Setlk(ctx, fh, input.Owner, &input.Lk, input.LkFlags))
 	}
-	if sl, ok := f.file.(FileSetlker); ok {
+	if sl, ok := fh.(FileSetlker); ok {
 		return errnoToStatus(sl.Setlk(ctx, input.Owner, &input.Lk, input.LkFlags))
 	}
 	return fuse.ENOTSUP
@@ -891,10 +921,14 @@
 func (b *rawBridge) SetLkw(cancel <-chan struct{}, input *fuse.LkIn) fuse.Status {
 	n, f := b.inode(input.NodeId, input.Fh)
 	ctx := &fuse.Context{Caller: input.Caller, Cancel: cancel}
+	var fh FileHandle
+	if f != nil {
+		fh = f.file
+	}
 	if lops, ok := n.ops.(NodeSetlkwer); ok {
-		return errnoToStatus(lops.Setlkw(ctx, f.file, input.Owner, &input.Lk, input.LkFlags))
+		return errnoToStatus(lops.Setlkw(ctx, fh, input.Owner, &input.Lk, input.LkFlags))
 	}
-	if sl, ok := f.file.(FileSetlkwer); ok {
+	if sl, ok := fh.(FileSetlkwer); ok {
 		return errnoToStatus(sl.Setlkw(ctx, input.Owner, &input.Lk, input.LkFlags))
 	}
 	return fuse.ENOTSUP
@@ -924,6 +958,9 @@
 
 func (b *rawBridge) ReleaseDir(input *fuse.ReleaseIn) {
 	n, f := b.releaseFileEntry(input.NodeId, input.Fh)
+	if f == nil {
+		return
+	}
 	f.wg.Wait()
 
 	if frd, ok := f.file.(FileReleasedirer); ok {
@@ -943,13 +980,48 @@
 	n := b.kernelNodeIds[nid]
 	var entry *fileEntry
 	if fh > 0 {
-		last := len(n.openFiles) - 1
+		// Bounds check to prevent panic from corrupted file handle
+		if fh >= uint64(len(b.files)) || b.files[fh] == nil {
+			return n, nil
+		}
 		entry = b.files[fh]
-		if last != entry.nodeIndex {
-			n.openFiles[entry.nodeIndex] = n.openFiles[last]
+
+		// Guard against empty openFiles slice
+		if len(n.openFiles) == 0 {
+			return n, nil
+		}
 
-			b.files[n.openFiles[entry.nodeIndex]].nodeIndex = entry.nodeIndex
+		last := len(n.openFiles) - 1
+
+		// Validate nodeIndex is within bounds AND points to correct file handle
+		if entry.nodeIndex < 0 || entry.nodeIndex > last || n.openFiles[entry.nodeIndex] != uint32(fh) {
+			// nodeIndex corrupted, search for actual position
+			found := false
+			for i, handleVal := range n.openFiles {
+				if handleVal == uint32(fh) {
+					entry.nodeIndex = i
+					found = true
+					break
+				}
+			}
+			if !found {
+				// File handle not in openFiles, state too corrupted
+				return n, nil
+			}
+			// Update last after we found the correct index
+			last = len(n.openFiles) - 1
 		}
+
+		if last != entry.nodeIndex {
+			// Capture values before modification to prevent double-access bugs
+			movedFileHandle := n.openFiles[last]
+			n.openFiles[entry.nodeIndex] = movedFileHandle
+
+			// Additional bounds check before accessing b.files with movedFileHandle
+			if movedFileHandle < uint32(len(b.files)) && b.files[movedFileHandle] != nil {
+				b.files[movedFileHandle].nodeIndex = entry.nodeIndex
+			}
+		}
 		n.openFiles = n.openFiles[:last]
 	}
 	return n, entry
@@ -959,11 +1031,15 @@
 	n, f := b.inode(input.NodeId, input.Fh)
 
 	ctx := &fuse.Context{Caller: input.Caller, Cancel: cancel}
+	var fh FileHandle
+	if f != nil {
+		fh = f.file
+	}
 	if wr, ok := n.ops.(NodeWriter); ok {
-		w, errno := wr.Write(ctx, f.file, data, int64(input.Offset))
+		w, errno := wr.Write(ctx, fh, data, int64(input.Offset))
 		return w, errnoToStatus(errno)
 	}
-	if fr, ok := f.file.(FileWriter); ok {
+	if fr, ok := fh.(FileWriter); ok {
 		w, errno := fr.Write(ctx, data, int64(input.Offset))
 		return w, errnoToStatus(errno)
 	}
@@ -974,10 +1050,14 @@
 func (b *rawBridge) Flush(cancel <-chan struct{}, input *fuse.FlushIn) fuse.Status {
 	n, f := b.inode(input.NodeId, input.Fh)
 	ctx := &fuse.Context{Caller: input.Caller, Cancel: cancel}
+	var fh FileHandle
+	if f != nil {
+		fh = f.file
+	}
 	if fl, ok := n.ops.(NodeFlusher); ok {
-		return errnoToStatus(fl.Flush(ctx, f.file))
+		return errnoToStatus(fl.Flush(ctx, fh))
 	}
-	if fl, ok := f.file.(FileFlusher); ok {
+	if fl, ok := fh.(FileFlusher); ok {
 		return errnoToStatus(fl.Flush(ctx))
 	}
 	return 0
@@ -986,10 +1066,14 @@
 func (b *rawBridge) Fsync(cancel <-chan struct{}, input *fuse.FsyncIn) fuse.Status {
 	n, f := b.inode(input.NodeId, input.Fh)
 	ctx := &fuse.Context{Caller: input.Caller, Cancel: cancel}
-	if fs, ok := n.ops.(NodeFsyncer); ok {
-		return errnoToStatus(fs.Fsync(ctx, f.file, input.FsyncFlags))
+	var fh FileHandle
+	if f != nil {
+		fh = f.file
 	}
-	if fs, ok := f.file.(FileFsyncer); ok {
+	if fs, ok := n.ops.(NodeFsyncer); ok {
+		return errnoToStatus(fs.Fsync(ctx, fh, input.FsyncFlags))
+	}
+	if fs, ok := fh.(FileFsyncer); ok {
 		return errnoToStatus(fs.Fsync(ctx, input.FsyncFlags))
 	}
 	return fuse.ENOTSUP
@@ -998,10 +1082,14 @@
 func (b *rawBridge) Fallocate(cancel <-chan struct{}, input *fuse.FallocateIn) fuse.Status {
 	n, f := b.inode(input.NodeId, input.Fh)
 	ctx := &fuse.Context{Caller: input.Caller, Cancel: cancel}
-	if a, ok := n.ops.(NodeAllocater); ok {
-		return errnoToStatus(a.Allocate(ctx, f.file, input.Offset, input.Length, input.Mode))
+	var fh FileHandle
+	if f != nil {
+		fh = f.file
 	}
-	if a, ok := f.file.(FileAllocater); ok {
+	if a, ok := n.ops.(NodeAllocater); ok {
+		return errnoToStatus(a.Allocate(ctx, fh, input.Offset, input.Length, input.Mode))
+	}
+	if a, ok := fh.(FileAllocater); ok {
 		return errnoToStatus(a.Allocate(ctx, input.Offset, input.Length, input.Mode))
 	}
 	return fuse.ENOTSUP
